// File automatically generated by /home/hernando/dev/src/config.stable/Pydoxine/CMake/../docstrings/sphinx_ext/cpp_docstrings.py

void initDocStrings(std::map<std::string, std::string> &m)
{
m["brain::Circuit"] = "\nRead access to a circuit database\n\nThis class provides convenience functions to access information about the cells inside the circuit and their morphologies. \n";
m["brain::Circuit::Circuit(const URI&)"] = "\nOpens a circuit for read access.\n\n**Parameters**\n\n     ``source`` -       the URI to the CircuitConfig or BlueConfig file. \n\n";
m["brain::Circuit::getAfferentSynapses"] = "\nAccess all afferent synapses of the given GIDs.\n\n**Parameters**\n\n     ``gids`` -       the gids to load afferent synapses for \n\n     ``prefetch`` -       which synapse data to preload \n\n";
m["brain::Circuit::getEfferentSynapses"] = "\nAccess all efferent synapses of the given GIDs.\n\n**Parameters**\n\n     ``gids`` -       the gids to load efferent synapses for \n\n     ``prefetch`` -       which synapse data to preload \n\n";
m["brain::Circuit::getElectrophysiologyNames"] = "\n**Return**\n    The electrophysiology type names of the circuit, indexed by ::`getElectrophysiologyTypes()`. \n\n";
m["brain::Circuit::getElectrophysiologyTypes"] = "\n**Return**\n    The electrophysiology type indices of the given cells. \n\n";
m["brain::Circuit::getGIDs() const"] = "\n**Return**\n    The set of all GIDs held by the circuit \n\n";
m["brain::Circuit::getGIDs(const std::string&) const"] = "\n**Return**\n    The set of GIDs for the given target name. \n\n**Exceptions**\n\n     ``std.runtime_error`` -       if the target cannot be found. \n\n";
m["brain::Circuit::getMorphologyNames"] = "\n**Return**\n    The morphology type names of the circuit, indexed by ::`getMorphologyTypes()`. \n\n";
m["brain::Circuit::getMorphologyTypes"] = "\n**Return**\n    The morphology type indices of the given cells. \n\n";
m["brain::Circuit::getMorphologyURIs"] = "\n**Return**\n    The set of URIs to access the morphologies of the given cells \n\n";
m["brain::Circuit::getNumNeurons"] = "\n**Return**\n    The number of neurons in the circuit. \n\n";
m["brain::Circuit::getPositions"] = "\n**Return**\n    The positions of the given cells. \n\n";
m["brain::Circuit::getProjectedSynapses"] = "\nAccess all synapses along the projection from the pre- to the postGIDs.\n\n**Parameters**\n\n     ``preGIDs`` -       the gids to load the efferent synapses for \n\n     ``postGIDs`` -       the gids to load the afferent synapses for \n\n     ``prefetch`` -       which synapse data to preload \n\n";
m["brain::Circuit::getRandomGIDs(float) const"] = "\n**Return**\n    A random fraction of GIDs from the circuit.  BRAIN_CIRCUIT_SEED set the seed for deterministic randomness \n\n**Exceptions**\n\n     ``std.runtime_error`` -       if the fraction is not in the range [0,1]. \n\n";
m["brain::Circuit::getRandomGIDs(float, const std::string&) const"] = "\n**Return**\n    A random fraction of GIDs from the given target name.  BRAIN_CIRCUIT_SEED set the seed for deterministic randomness \n\n**Exceptions**\n\n     ``std.runtime_error`` -       if the fraction is not in the range [0,1]. \n\n     ``std.runtime_error`` -       if the target cannot be found. \n\n";
m["brain::Circuit::getRotations"] = "\n**Return**\n    A Nx4 numpy array with the local to world rotation of the given cells. \n\n";
m["brain::Circuit::getTransforms"] = "\n**Return**\n    A Nx4 numpy array with the local to world transformations of the given cells. \n\n";
m["brain::Circuit::loadMorphologies"] = "\n**Return**\n    The list of morpholgies for the GID set. If local coordinates are requested, morphologies that are repeated in the circuit will shared the same Morphology object in the list. If global coordinates are requested, all Morphology objects are unique. \n\n";
m["brain::Synapse"] = "\nA proxy object returned by the Synapses container to access data for a particular synapse.\n\nThe lifetime of this object is stricly bound to the synapses container it comes from. \n";
m["brain::Synapse::getConductance"] = "\n**Return**\n    the conductance in nanosiemens. \n\n";
m["brain::Synapse::getDecay"] = "\n**Return**\n    the decay time constant in milliseconds. \n\n";
m["brain::Synapse::getDelay"] = "\n**Return**\n    the axonal delay in milliseconds. \n\n";
m["brain::Synapse::getDepression"] = "\n**Return**\n    the depression time constant in milliseconds. \n\n";
m["brain::Synapse::getEfficacy"] = "\n**Return**\n    the absolute synaptic efficacy in millivolts. \n\n";
m["brain::Synapse::getFacilitation"] = "\n**Return**\n    the facilitation time constant in milliseconds. \n\n";
m["brain::Synapse::getPostsynapticCenterPosition"] = "\n**Return**\n    the postsynaptic touch position in the center of the segment. \n\n";
m["brain::Synapse::getPostsynapticDistance"] = "\n**Return**\n    the distance in micrometer to the postsynaptic neuron. \n\n";
m["brain::Synapse::getPostsynapticGID"] = "\n**Return**\n    the GID of the postsynaptic neuron. \n\n";
m["brain::Synapse::getPostsynapticSectionID"] = "\n**Return**\n    the section ID on the postsynaptic neuron. \n\n";
m["brain::Synapse::getPostsynapticSegmentID"] = "\n**Return**\n    the segment ID on the postsynaptic neuron. \n\n";
m["brain::Synapse::getPostsynapticSurfacePosition"] = "\n**Return**\n    the postsynaptic touch position on the surface of the segment. \n\n";
m["brain::Synapse::getPresynapticCenterPosition"] = "\n**Return**\n    the presynaptic touch position in the center of the segment. \n\n";
m["brain::Synapse::getPresynapticDistance"] = "\n**Return**\n    the distance in micrometer to the presynaptic neuron. \n\n";
m["brain::Synapse::getPresynapticGID"] = "\n**Return**\n    the GID of the presynaptic neuron. \n\n";
m["brain::Synapse::getPresynapticSectionID"] = "\n**Return**\n    the section ID on the presynaptic neuron. \n\n";
m["brain::Synapse::getPresynapticSegmentID"] = "\n**Return**\n    the segment ID on the presynaptic neuron. \n\n";
m["brain::Synapse::getPresynapticSurfacePosition"] = "\n**Return**\n    the presynaptic touch position on the surface of the segment. \n\n";
m["brain::Synapse::getUtilization"] = "\n**Return**\n    the neuro-transmitter release probability. \n\n";
m["brain::SynapsePrefetch"] = "\nLoading of data during SynapsesStream.read(), otherwise load happens on-demand. \n\n*Values:*\n * none: \nonly loads pre- and post GIDs \n * attributes: \ntopological information (section, segment, distance) and model attributes \n * positions: \npre/post surface/center positions \n * all: \nall synapse data \n";
m["brain::Synapses"] = "\nA container providing read-only access to Synapses retrieved by getXXXSynapses() functions from brain.Circuit. It provides per-object and per-array access on the various synapses attributes. Data which was not prefetched will be loaded on-demand.\n\nThis container can be iterator as well as random accessed using the operator [].\n\nThis class is thread-safe, moveable and copyable. \n";
m["brain::Synapses::conductances"] = "\n**Return**\n    the conductances in nanosiemens. \n\n";
m["brain::Synapses::decays"] = "\n**Return**\n    the decay time constants in milliseconds. \n\n";
m["brain::Synapses::delays"] = "\n**Return**\n    the axonal delays in milliseconds. \n\n";
m["brain::Synapses::depressions"] = "\n**Return**\n    the depression time constants in milliseconds. \n\n";
m["brain::Synapses::efficacies"] = "\n**Return**\n    the absolute synaptic efficacies in millivolts. \n\n";
m["brain::Synapses::empty"] = "\n**Return**\n    size() == 0. \n\n";
m["brain::Synapses::facilitations"] = "\n**Return**\n    the facilitation time constants in milliseconds. \n\n";
m["brain::Synapses::indices"] = "\n**Return**\n    the synapse GIDs containing GIDs of the post-synaptic cells and the indices in the afferent contacts array. \n\n**Exceptions**\n\n     ``std.runtime_error`` -       if index information not found in the synapse source of the circuit. \n\n";
m["brain::Synapses::postCenterXPositions"] = "\n**Return**\n    the postsynaptic touch position x-coordinates in the center of the segments. \n\n";
m["brain::Synapses::postCenterYPositions"] = "\n**Return**\n    the postsynaptic touch position y-coordinates in the center of the segments. \n\n";
m["brain::Synapses::postCenterZPositions"] = "\n**Return**\n    the postsynaptic touch position z-coordinates in the center of the segments. \n\n";
m["brain::Synapses::postDistances"] = "\n**Return**\n    the distances in micrometer to the postsynaptic neurons. \n\n";
m["brain::Synapses::postGIDs"] = "\n**Return**\n    the GIDs of the postsynaptic neurons. \n\n";
m["brain::Synapses::postSectionIDs"] = "\n**Return**\n    the section IDs on the postsynaptic neurons. \n\n";
m["brain::Synapses::postSegmentIDs"] = "\n**Return**\n    the segment IDs on the postsynaptic neurons. \n\n";
m["brain::Synapses::postSurfaceXPositions"] = "\n**Return**\n    the postsynaptic touch position x-coordinates on the surfaces of the segments. \n\n";
m["brain::Synapses::postSurfaceYPositions"] = "\n**Return**\n    the postsynaptic touch position x-coordinates on the surfaces of the segments. \n\n";
m["brain::Synapses::postSurfaceZPositions"] = "\n**Return**\n    the postsynaptic touch position x-coordinates on the surfaces of the segments. \n\n";
m["brain::Synapses::preCenterXPositions"] = "\n**Return**\n    the presynaptic touch position x-coordinates in the center of the segments. \n\n";
m["brain::Synapses::preCenterYPositions"] = "\n**Return**\n    the presynaptic touch position y-coordinates in the center of the segments. \n\n";
m["brain::Synapses::preCenterZPositions"] = "\n**Return**\n    the presynaptic touch position z-coordinates in the center of the segments. \n\n";
m["brain::Synapses::preDistances"] = "\n**Return**\n    the distances in micrometer to the presynaptic neurons. \n\n";
m["brain::Synapses::preGIDs"] = "\n**Return**\n    the GIDs of the presynaptic neurons. \n\n";
m["brain::Synapses::preSectionIDs"] = "\n**Return**\n    the section IDs on the presynaptic neurons. \n\n";
m["brain::Synapses::preSegmentIDs"] = "\n**Return**\n    the segment IDs on the presynaptic neurons. \n\n";
m["brain::Synapses::preSurfaceXPositions"] = "\n**Return**\n    the presynaptic touch position x-coordinates on the surfaces of the segments. \n\n";
m["brain::Synapses::preSurfaceYPositions"] = "\n**Return**\n    the presynaptic touch position y-coordinates on the surfaces of the segments. \n\n";
m["brain::Synapses::preSurfaceZPositions"] = "\n**Return**\n    the presynaptic touch position z-coordinates on the surfaces of the segments. \n\n";
m["brain::Synapses::utilizations"] = "\n**Return**\n    the neuro-transmitter release probabilities. \n\n";
m["brain::neuron::Morphology"] = "\nWrapper around brion.Morphology with higher level functions.\n\nThis class provides methods to facilitate some queries about morphologies in the context of circuits. Morphologies can be loaded with a transformation applied to its points, which is useful for operating in global circuit coordinates. The transformation is applied at construction so it cannot be modified or reverted.\n\nAccess to the raw data fields is still provided by getter functions.\n\n**Version**\n    unstable \n\n\nInherits from noncopyable\n";
m["brain::neuron::Morphology::Morphology(const URI&)"] = "\nCreate a morphology from a URI and load all the data.\n\n**Parameters**\n\n     ``source`` -       URI of the morphology data source. \n\n**Exceptions**\n\n     ``runtime_error`` -       if an inconsistency is detected in the input file. \n\n";
m["brain::neuron::Morphology::Morphology(const URI&, const Matrix4f&)"] = "\nCreate a morphology from a URI, load all the data and transform the points.\n\n**Parameters**\n\n     ``source`` -       URI of the morphology data source. \n\n     ``transform`` -       the transformation matrix to apply to the points. Radii will not be affected by this transformation. \n\n**Exceptions**\n\n     ``runtime_error`` -       if an inconsistency is detected in the input file. \n\n";
m["brain::neuron::Morphology::getSectionIDs"] = "\nReturn the list of ids for the given section types. \n";
m["brain::neuron::Morphology::getSections(SectionType) const"] = "\nReturn the sections which have the given section type. If type is SectionType.Soma an empty list is returned. \n";
m["brain::neuron::Morphology::getSections(const SectionTypes&) const"] = "\nReturn the sections which have any of the given section types. No sections are returned for the type SectionType.Soma. \n";
m["brain::neuron::Morphology::getSoma"] = "\nReturn the object with the information about the neuron soma \n";
m["brain::neuron::Morphology::getTransformation"] = "\nReturn a 4x4 numpry arry with the transformation that was passed to the constructor or the identity matrix is no transformation was given. \n";
m["brain::neuron::Section"] = "\nA class to represent a morphological section.\n\nA Section is an unbranched piece of a morphological skeleton. This class provides functions to query information about the sample points that compose the section and functions to obtain the parent and children sections.\n\nThe cell soma is also considered a section, but some functions have special meaning for it.\n\nSections cannot be directly created, but are returned by several brain.Morphology and brain.Section methods.\n\nThis is a lightweight object with STL container style thread safety. It is also safe to use a section after the morphology from where it comes has been deallocated. The morphological data will be kept as long as there is a Section referring to it. \n";
m["brain::neuron::Section::getChildren"] = "\nReturn a vector with all the direct children of this section. The container will be empty for terminal sections. \n";
m["brain::neuron::Section::getDistanceToSoma"] = "\nReturn the absolute distance from the start of the section to the soma. \n";
m["brain::neuron::Section::getID"] = "\nReturn the ID of this section. \n";
m["brain::neuron::Section::getLength"] = "\nReturn the total length of this section in microns.\n\nIf this section is a soma section the length is ill-defined and this function will return 0. \n";
m["brain::neuron::Section::getParent"] = "\nReturn the parent section of this section or None if doesn't have any. \n";
m["brain::neuron::Section::getSampleDistancesToSoma"] = "\nReturn the absolute distances to the soma in microns for all sample positions.\n\n**Return**\n    A list of distances. For a section consisting of n segments, this list will have n + 1 values. The section length is equal to the difference between the first and last values of the list. \n\n";
m["brain::neuron::Section::getSamples() const"] = "\nReturn the list of all point samples that define this section.\n\nIf this sections is a soma section return the list of points of the soma profile poly-line.\n\n**Return**\n    A list of point positions with radius. For a section consisting of n segments, this list will have n + 1 points. \n\n";
m["brain::neuron::Section::getSamples(const floats&) const"] = "\nReturn a list of points sampling this section at discrete locations.\n\nIf the section is a soma section this function will return the soma position for all sampling positions. The soma position is assumed to be (0, 0, 0) unless the origin morphology has been transformed.\n\n**Return**\n    The section sampled at the given relative positions. \n\n**Parameters**\n\n     ``points`` -       Normalized positions of the sample points along the section. Values will be clampled to [0, 1] before sampling. \n\n";
m["brain::neuron::Section::getType"] = "\nReturn the morphological type of this section (dendrite, axon, ...). \n";
m["brain::neuron::Soma"] = "\nA class to represent a neuron soma.\n\nThis class provides functions to query information about the soma of a neuron.\n\nTypically the soma is described as the poly-line of the projection of the soma onto a plane, where the plane normal points in the vertical direction in the local coordinate system of the morphology. In other cases the poly-line is not projected onto a plane, but is an approximation of the countour of the soma as seen in an orhogonal projection down the vertical axis (this is basically the same as before, but the vertical coordinate is not 0 for all the points). This class can also be used for both descriptions as well as somas simply approximated as spheres.\n\nThe coordinates system used by a soma will be in the same as the brain.Morphology from where it comes.\n\n**Version**\n    unstable \n\n";
m["brain::neuron::Soma::getCentroid"] = "\nReturn the average of the profile points. \n";
m["brain::neuron::Soma::getMeanRadius"] = "\nReturn the mean distance between the profile points and the centroid. \n";
m["brain::neuron::Soma::getProfilePoints"] = "\nReturn the x,y,z and radius of the points of the soma profile as a 4xN numpy array. \n";
}
